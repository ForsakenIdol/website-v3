---
apiVersion: v1
kind: ConfigMap
metadata:
  namespace: website
  name: database-connection-script
data:
  # The 'pg' library will pull Client parameters from the environment if we don't specify them as arguments.
  # We opt to provide the password and host parameters in this way.
  server.js: |
    const { Client } = require('pg');
    const express = require('express');

    /* Helper Functions */

    const getDateString = offset => { return (Date() + offset).split(' (')[0]; }
    const offset = 8; // Fixed for AWST for now.

    const logMessage = message => { console.log(`[${getDateString(offset)}] ${message}`); }

    /* App Setup */

    const client = new Client({
        // The host and password are platform-dependent and so we pass these as environment variables.
        user: 'postgres',
        database: 'website',
        port: 5432
    });

    const app = express();
    const app_port = process.env.EXPRESSPORT;

    app.listen(app_port, () => {
        logMessage(`Server listening on port ${app_port}.`);
        client.connect(err => {
            if (err) {
                logMessage(err);
                throw "There was an error connecting to the PostgreSQL database.";
            }
            else logMessage(`Connected to the PostgreSQL database at '${process.env.PGHOST}'.`);
        });
    });

    /* Admin Paths */

    app.get('/kill', (req, res) => {
        logMessage(`GET /kill`);
        client.end()
        .then(() => {
            logMessage("Successfully disconnected client.");
            res.status(200).send({
                'status': 200,
                'response': { 'message': "Successfully disconnected client." }
            });
            process.exit(0);
        })
        .catch(error => {
            logMessage("Error during disconnection.");
            res.status(500).send({
                'status': 500,
                'response': { 'message': "Error during disconnection." }
            });
            process.exit(1);
        });
    })

    /* 
    * CRD Paths (We don't need an Update path, since we won't be checking if rows change,
    * at every update we'll just delete and re-add the row since the primary key is the
    * repo ID.)
    */

    // CREATE (POST) new row

    app.post('/create', (req, res) => {
        logMessage("POST /create");
        return res.status(501). send({
            'status': 501,
            'response': { 'message': "Not implemented!" }
        })
    });

    // GET all

    app.get('/get', (req, res) => {
        logMessage("GET /get");
        client.query('SELECT * FROM github;', (err, db_res) => {
            if (err) {
                logMessage(err);
                return res.status(500).send({
                    'status': 500,
                    'response': { 'message': 'There was an error processing your request.' }
                });
            }
            else {
                logMessage(`Returned ${db_res.rows.length} rows.`);
                return res.status(200).send({
                    'status': 200,
                    'response': { 'rows': db_res.rows }
                });
            }
        });
    });

    // GET by repo_id

    app.get('/get/id/:id', (req, res) => {
        logMessage(`GET /get/id/${req.params.id}`);
        const query = "SELECT * FROM github WHERE repo_id = $1;";
        const parameters = [ req.params.id ];
        client.query(query, parameters, (err, db_res) => {
            if (err) {
                logMessage(err);
                return res.status(500).send({
                    'status': 500,
                    'response': { 'message': 'There was an error processing your request.' }
                });
            }
            else {
                logMessage(`Returned ${db_res.rows.length} rows.`);
                return res.status(200).send({
                    'status': 200,
                    'response': { 'rows': db_res.rows }
                });
            }
        });
    });
---
# Right now, we're just making a standalone pod,
# but eventually we'll wrap it in a 1-count deployment and service for our frontend.
apiVersion: v1
kind: Pod
metadata:
  namespace: website
  name: pod-nodejs
spec:
  containers:
  - name: container-nodejs
    image: node:18 # We opt not for the Alpine build since I do need some editing tools to test
    command: ["sleep"]
    args: ["6000"]
    env:
      - name: PGHOST
        value: 'postgres-service.website'
      # We pull the password from the 2_credentials secret created previously.
      - name: PGPASSWORD
        valueFrom:
          secretKeyRef:
            name: postgres-credentials
            key: POSTGRES_PASSWORD
        # Even numbers need to be passed as strings to pods for environment variables.
      - name: EXPRESSPORT
        value: '9001'
    volumeMounts:
    - name: database-connection-script
      mountPath: /scripts/server.js
      subPath: server.js
  volumes:
  - name: database-connection-script
    configMap:
        name: database-connection-script
        items:
          - key: server.js
            path: server.js
---
